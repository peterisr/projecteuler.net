/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 * sTriangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
 * Square 	  	    P4,n=n2 	  	    1, 4, 9, 16, 25, ...
 * Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
 * Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
 * Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
 * Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...
 *
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 *
 * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 *
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 * triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 *
 * @task 061
 * @answer 28684
 */
#include "../projecteuler.h"

#define TO 10000

UI classes[TO],
    start[100][TO],
    startc[TO];
bool used[TO];

void numberClassification() {
    memset(classes, 0, sizeof classes);

    UI n, i;

    // Triangle
    i = 0;
    do {
        i++;
        n = i * (i + 1) / 2;
    } while (n < TO && (classes[n] |= (1 << 3)));


    // Square
    i = 0;
    do {
        i++;
        n = i * i;
    } while (n < TO && (classes[n] |= (1 << 4)));


    // Pentagonal
    i = 0;
    do {
        i++;
        n = i * (3 * i - 1) / 2;
    } while (n < TO && (classes[n] |= (1 << 5)));


    // Hexagonal
    i = 0;
    do {
        i++;
        n = i * (2 * i - 1);
    } while (n < TO && (classes[n] |= (1 << 6)));


    // Heptagonal
    i = 0;
    do {
        i++;
        n = i * (5 * i - 3) / 2;
    } while (n < TO && (classes[n] |= (1 << 7)));


    // Octagonal
    i = 0;
    do {
        i++;
        n = i * (3 * i - 2);
    } while (n < TO && (classes[n] |= (1 << 8)));
}

void groupingsByStart() {
    memset(startc, 0, sizeof startc);
    FOR(i,1000,10000) {
        UI belongsToClasses = __builtin_popcount(classes[i]);
        if (!classes[i]) {
            classes[i] = 0;
            continue;
        }

        start[i / 100][startc[i / 100]++] = i;
    }
}

UI getSetSum(UI firstNumber, UI lastNumber, UI have, UI length) {
    UI startWith = lastNumber % 100;
    F(i,startc[startWith]) {
        UI possibleNext = start[startWith][i];

        if (used[possibleNext] || possibleNext % 100 < 10) {
            continue;
        }

        used[possibleNext] = 1;
        if (length == 5) {
            if (
                __builtin_popcount(have | classes[possibleNext]) == 6
                && firstNumber / 100 == possibleNext % 100
            ) {
                UI sum = 0;

                FOR(i,1000,10000) {
                    if (used[i]) {
                        //TRACE(i);
                        sum += i;
                    }
                }

                return sum;
            }
        } else {
            for(UI c = classes[possibleNext], x = 0; c; c>>=1, x++) {
                if ((c & 1) && 0 == (have & (1 << x))) {
                    UI sum = getSetSum(firstNumber, possibleNext, (have | (1 << x)), length + 1);
                    if (sum) {
                        return sum;
                    }
                }
            }
        }

        used[possibleNext] = 0;
    }

    return 0;
}

UI getSetSum() {
    memset(used, 0, sizeof used);
    FOR(i,1000,TO) {
        if (!classes[i] || i % 100 < 10) {
            continue;
        }

        used[i] = 1;
        for(UI c = classes[i], x = 0; c; c>>=1, x++) {
            if ((c & 1)) {
                UI sum = getSetSum(i, i, (1 << x), 1);
                if (sum) {
                    return sum;
                }
            }
        }
        used[i] = 0;
    }
}

UI solve061() {
    numberClassification();
    groupingsByStart();
    return getSetSum();
}

int main() {
    cout << solve061();
    return 0;
}
